{
  parserClass="ch.erzberger.sharpbasic.parser.SharpBasicParser"
  parserUtilClass="ch.erzberger.sharpbasic.parser.SharpBasicParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SharpBasic"
  psiImplClassSuffix="Impl"
  psiPackage="ch.erzberger.sharpbasic.psi"
  psiImplPackage="ch.erzberger.sharpbasic.psi.impl"

  elementTypeHolderClass="ch.erzberger.sharpbasic.psi.SharpBasicTypes"
  elementTypeClass="ch.erzberger.sharpbasic.psi.SharpBasicElementType"
  tokenTypeClass="ch.erzberger.sharpbasic.psi.SharpBasicTokenType"

  tokens = [
    LINE_NUMBER='regexp:[0-9]+'
    NUMBER='regexp:([0-9]*\.[0-9]+|[0-9]+\.?[0-9]*)([Ee][+\-]?[0-9]+)?'
    STRING='regexp:"([^"\r\n]|"")*"'
    IDENTIFIER='regexp:[A-Za-z][A-Za-z0-9]*\$?'
    KEYWORD='regexp:[A-Za-z]+\.?'
    COMMENT='regexp:REM[^\r\n]*'

    PLUS='+'
    MINUS='-'
    MULT='*'
    DIV='/'
    POWER='^'
    EQ='='
    LT='<'
    GT='>'
    LE='<='
    GE='>='
    NE='<>'
    LPAREN='('
    RPAREN=')'
    COMMA=','
    SEMICOLON=';'
    COLON=':'
    HASH='#'

    LINE_TERMINATOR='regexp:\r\n|\r|\n'
  ]
}

file ::= line*

line ::= LINE_NUMBER statement_list? LINE_TERMINATOR?
       | statement_list LINE_TERMINATOR?
       | LINE_TERMINATOR

statement_list ::= statement (COLON statement)*

statement ::= for_stmt
            | next_stmt
            | if_stmt
            | goto_stmt
            | gosub_stmt
            | return_stmt
            | input_stmt
            | print_stmt
            | dim_stmt
            | data_stmt
            | read_stmt
            | rem_stmt
            | end_stmt
            | other_stmt
            | let_stmt
            | expression

print_stmt ::= <<isKeyword "PRINT">> print_items?
             | <<isKeyword "LPRINT">> print_items?
print_items ::= (expression | print_sep) (print_continuation)*
print_continuation ::= (expression | print_sep)
print_sep ::= COMMA | SEMICOLON

for_stmt ::= <<isKeyword "FOR">> IDENTIFIER EQ comparison_expr <<isKeyword "TO">> comparison_expr (<<isKeyword "STEP">> comparison_expr)?

next_stmt ::= <<isKeyword "NEXT">> IDENTIFIER?

if_stmt ::= <<isKeyword "IF">> comparison_expr (<<isKeyword "THEN">> | <<isKeyword "GOTO">>) (statement | LINE_NUMBER)

goto_stmt ::= <<isKeyword "GOTO">> LINE_NUMBER

gosub_stmt ::= <<isKeyword "GOSUB">> LINE_NUMBER

return_stmt ::= <<isKeyword "RETURN">>

input_stmt ::= <<isKeyword "INPUT">> (STRING (COMMA | SEMICOLON))? variable (print_sep? (STRING print_sep?)? variable)*

let_stmt ::= <<isKeyword "LET">> assignment (COMMA assignment)*
           | assignment_lookahead assignment (COMMA assignment)*

private assignment_lookahead ::= &((IDENTIFIER | KEYWORD) (LPAREN expression_list RPAREN)? EQ)

assignment ::= (IDENTIFIER | KEYWORD) (LPAREN expression_list RPAREN)? EQ expression

dim_stmt ::= <<isKeyword "DIM">> dim_variable_list
dim_variable_list ::= dim_variable (COMMA dim_variable)*
dim_variable ::= variable (MULT NUMBER)?

data_stmt ::= <<isKeyword "DATA">> expression_list

read_stmt ::= <<isKeyword "READ">> variable_list

rem_stmt ::= COMMENT

end_stmt ::= <<isKeyword "END">>

other_stmt ::= !assignment_lookahead KEYWORD print_items?

expression_list ::= expression ((COMMA | SEMICOLON) expression)*

variable_list ::= variable (COMMA variable)*

variable ::= (IDENTIFIER | KEYWORD) (LPAREN expression_list RPAREN)?

expression ::= logical_expr

logical_expr ::= comparison_expr (logical_op comparison_expr)*

logical_op ::= <<isKeyword "AND">> | <<isKeyword "OR">>

comparison_expr ::= additive_expr (comparison_op additive_expr)*

comparison_op ::= EQ | LT | GT | LE | GE | NE

additive_expr ::= multiplicative_expr ((PLUS | MINUS) multiplicative_expr)*

multiplicative_expr ::= power_expr ((MULT | DIV) power_expr)*

power_expr ::= unary_expr (POWER unary_expr)*

unary_expr ::= (PLUS | MINUS | <<isKeyword "NOT">>)? primary_expr  // KEYWORD for NOT

primary_expr ::= NUMBER
               | STRING
               | IDENTIFIER (LPAREN expression_list? RPAREN)?  // Variable or function call
               | <<isKeyword "LEFT$">> LPAREN expression_list RPAREN
               | <<isKeyword "RIGHT$">> LPAREN expression_list RPAREN
               | <<isKeyword "MID$">> LPAREN expression_list RPAREN
               | KEYWORD primary_expr                          // Function without parens
               | KEYWORD (LPAREN expression_list? RPAREN)?     // Keyword function with parens
               | LPAREN expression_list RPAREN                 // Parenthesized expression list
